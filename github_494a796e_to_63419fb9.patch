commit 494a796e112869cf5df482dc7618868eca7cf2d5
Author: Dave Anderson <anderson@redhat.com>
Date:   Tue Nov 28 09:24:39 2017 -0500

    Fix to support Linux 4.15 and later kernels that contain kernel
    commit e8cfbc245e24887e3c30235f71e9e9405e0cfc39, titled "pid: remove
    pidhash".  The kernel's traditional usage of a pid_hash[] array to
    store PIDs has been replaced by an IDR radix tree, requiring a new
    crash plug-in function to gather the system's task set.  Without the
    patch, the crash session fails during initialization with the error
    message "crash: cannot resolve init_task_union".
    (anderson@redhat.com)

diff --git a/defs.h b/defs.h
index 9132075..ba9abad 100644
--- a/defs.h
+++ b/defs.h
@@ -845,6 +845,8 @@ struct task_table {                      /* kernel/local task table data */
 	long anonpages;
 	ulong stack_end_magic;
 	ulong pf_kthread;
+	ulong pid_radix_tree;
+	int callbacks;
 };
 
 #define TASK_INIT_DONE       (0x1)
@@ -864,6 +866,7 @@ struct task_table {                      /* kernel/local task table data */
 #define ACTIVE_ONLY       (0x4000)
 #define START_TIME_NSECS  (0x8000)
 #define THREAD_INFO_IN_TASK (0x10000)
+#define PID_RADIX_TREE   (0x20000)
 
 #define TASK_SLUSH (20)
 
@@ -1996,6 +1999,8 @@ struct offset_table {                    /* stash of commonly-used offsets */
 	long mod_arch_specific_orc_unwind;
 	long task_struct_policy;
 	long kmem_cache_random;
+	long pid_namespace_idr;
+	long idr_idr_rt;
 };
 
 struct size_table {         /* stash of commonly-used sizes */
@@ -2146,6 +2151,7 @@ struct size_table {         /* stash of commonly-used sizes */
 	long sk_buff_len;
 	long orc_entry;
 	long task_struct_policy;
+	long pid;
 };
 
 struct array_table {
diff --git a/filesys.c b/filesys.c
index f9a7797..1b44ad5 100644
--- a/filesys.c
+++ b/filesys.c
@@ -2083,38 +2083,6 @@ vfs_init(void)
 	if (!(ft->inode_cache = (char *)malloc(SIZE(inode)*INODE_CACHE)))
 		error(FATAL, "cannot malloc inode cache\n");
 
-	if (symbol_exists("height_to_maxindex") ||
-	    symbol_exists("height_to_maxnodes")) {
-		int newver = symbol_exists("height_to_maxnodes");
-		int tmp ATTRIBUTE_UNUSED;
-		if (!newver) {
-			if (LKCD_KERNTYPES())
-				ARRAY_LENGTH_INIT_ALT(tmp, "height_to_maxindex",
-					"radix_tree_preload.nodes", NULL, 0);
-			else
-				ARRAY_LENGTH_INIT(tmp, height_to_maxindex,
-					"height_to_maxindex", NULL, 0);
-		} else {
-			if (LKCD_KERNTYPES())
-				ARRAY_LENGTH_INIT_ALT(tmp, "height_to_maxnodes",
-					"radix_tree_preload.nodes", NULL, 0);
-			else
-				ARRAY_LENGTH_INIT(tmp, height_to_maxnodes,
-					"height_to_maxnodes", NULL, 0);
-		}
-		STRUCT_SIZE_INIT(radix_tree_root, "radix_tree_root");
-		STRUCT_SIZE_INIT(radix_tree_node, "radix_tree_node");
-		MEMBER_OFFSET_INIT(radix_tree_root_height, 
-			"radix_tree_root","height");
-		MEMBER_OFFSET_INIT(radix_tree_root_rnode, 
-			"radix_tree_root","rnode");
-		MEMBER_OFFSET_INIT(radix_tree_node_slots, 
-			"radix_tree_node","slots");
-		MEMBER_OFFSET_INIT(radix_tree_node_height, 
-			"radix_tree_node","height");
-		MEMBER_OFFSET_INIT(radix_tree_node_shift,
-			"radix_tree_node","shift");
-	}
 	MEMBER_OFFSET_INIT(rb_root_rb_node, 
 		"rb_root","rb_node");
 	MEMBER_OFFSET_INIT(rb_node_rb_left, 
diff --git a/symbols.c b/symbols.c
index 0d85ff7..2372887 100644
--- a/symbols.c
+++ b/symbols.c
@@ -8608,6 +8608,10 @@ dump_offset_table(char *spec, ulong makestruct)
 	fprintf(fp, "            mnt_namespace_list: %ld\n",
 		OFFSET(mnt_namespace_list));
 
+	fprintf(fp, "             pid_namespace_idr: %ld\n",
+		OFFSET(pid_namespace_idr));
+	fprintf(fp, "                    idr_idr_rt: %ld\n",
+		OFFSET(idr_idr_rt));
         fprintf(fp, "                  pid_link_pid: %ld\n",
                 OFFSET(pid_link_pid));
         fprintf(fp, "                pid_hash_chain: %ld\n",
@@ -10349,6 +10353,8 @@ dump_offset_table(char *spec, ulong makestruct)
 		SIZE(pid_link));
 	fprintf(fp, "                          upid: %ld\n", 
 		SIZE(upid));
+	fprintf(fp, "                           pid: %ld\n",
+		SIZE(pid));
 	fprintf(fp, "                  unwind_table: %ld\n", 
 		SIZE(unwind_table));
 	fprintf(fp, "                        rlimit: %ld\n", 
diff --git a/task.c b/task.c
index 724532d..b303ef7 100644
--- a/task.c
+++ b/task.c
@@ -30,6 +30,8 @@ static void refresh_hlist_task_table(void);
 static void refresh_hlist_task_table_v2(void);
 static void refresh_hlist_task_table_v3(void);
 static void refresh_active_task_table(void);
+static int radix_tree_task_callback(ulong);
+static void refresh_radix_tree_task_table(void);
 static struct task_context *store_context(struct task_context *, ulong, char *);
 static void refresh_context(ulong, ulong);
 static ulong parent_of(ulong);
@@ -439,12 +441,55 @@ task_init(void)
 	    	((len = SIZE(thread_union)) != STACKSIZE())) 
 		machdep->stacksize = len;
 
+	MEMBER_OFFSET_INIT(pid_namespace_idr, "pid_namespace", "idr");
+	MEMBER_OFFSET_INIT(idr_idr_rt, "idr", "idr_rt");
+
+	if (symbol_exists("height_to_maxindex") ||
+	    symbol_exists("height_to_maxnodes")) {
+		int newver = symbol_exists("height_to_maxnodes");
+		int tmp ATTRIBUTE_UNUSED;
+		if (!newver) {
+			if (LKCD_KERNTYPES())
+				ARRAY_LENGTH_INIT_ALT(tmp, "height_to_maxindex",
+					"radix_tree_preload.nodes", NULL, 0);
+			else
+				ARRAY_LENGTH_INIT(tmp, height_to_maxindex,
+					"height_to_maxindex", NULL, 0);
+		} else {
+			if (LKCD_KERNTYPES())
+				ARRAY_LENGTH_INIT_ALT(tmp, "height_to_maxnodes",
+					"radix_tree_preload.nodes", NULL, 0);
+			else
+				ARRAY_LENGTH_INIT(tmp, height_to_maxnodes,
+					"height_to_maxnodes", NULL, 0);
+		}
+		STRUCT_SIZE_INIT(radix_tree_root, "radix_tree_root");
+		STRUCT_SIZE_INIT(radix_tree_node, "radix_tree_node");
+		MEMBER_OFFSET_INIT(radix_tree_root_height,
+			"radix_tree_root","height");
+		MEMBER_OFFSET_INIT(radix_tree_root_rnode,
+			"radix_tree_root","rnode");
+		MEMBER_OFFSET_INIT(radix_tree_node_slots,
+			"radix_tree_node","slots");
+		MEMBER_OFFSET_INIT(radix_tree_node_height,
+			"radix_tree_node","height");
+		MEMBER_OFFSET_INIT(radix_tree_node_shift,
+			"radix_tree_node","shift");
+	}
+
 	if (symbol_exists("pidhash") && symbol_exists("pid_hash") &&
 	    !symbol_exists("pidhash_shift"))
 		error(FATAL, 
         "pidhash and pid_hash both exist -- cannot distinquish between them\n");
 
-	if (symbol_exists("pid_hash") && symbol_exists("pidhash_shift")) {
+	if (VALID_MEMBER(pid_namespace_idr)) {
+		STRUCT_SIZE_INIT(pid, "pid");
+		tt->refresh_task_table = refresh_radix_tree_task_table;
+		tt->pid_radix_tree = symbol_value("init_pid_ns") +
+			OFFSET(pid_namespace_idr) + OFFSET(idr_idr_rt);
+		tt->flags |= PID_RADIX_TREE;
+
+	} else if (symbol_exists("pid_hash") && symbol_exists("pidhash_shift")) {
 		int pidhash_shift;
 
 	   	if (get_symbol_type("PIDTYPE_PID", NULL, &req) != 
@@ -2271,6 +2316,233 @@ chain_next:
 	tt->retries = MAX(tt->retries, retries);
 }
 
+/*
+ *  Linux 4.15: pid_hash[] replaced by IDR/radix_tree
+ */
+static int
+radix_tree_task_callback(ulong task)
+{
+	ulong *tlp;
+
+	if (tt->callbacks < tt->max_tasks) {
+		tlp = (ulong *)tt->task_local;
+		tlp += tt->callbacks++;
+		*tlp = task;
+	}
+
+	return TRUE;
+}
+
+static void
+refresh_radix_tree_task_table(void)
+{
+	int i, cnt;
+	ulong count, retries, next, curtask, curpid, upid_ns, pid_tasks_0, task;
+	ulong *tlp;
+	char *tp;
+	struct radix_tree_pair rtp;
+	struct task_context *tc;
+	char *pidbuf;
+
+	if (DUMPFILE() && (tt->flags & TASK_INIT_DONE))   /* impossible */
+		return;
+
+	if (DUMPFILE()) {                                 /* impossible */
+		please_wait("gathering task table data");
+		if (!symbol_exists("panic_threads"))
+			tt->flags |= POPULATE_PANIC;
+	}
+
+	if (ACTIVE() && !(tt->flags & TASK_REFRESH))
+		return;
+
+	curpid = NO_PID;
+	curtask = NO_TASK;
+
+	/*
+	 *  The current task's task_context entry may change,
+	 *  or the task may not even exist anymore.
+	 */
+	if (ACTIVE() && (tt->flags & TASK_INIT_DONE)) {
+		curtask = CURRENT_TASK();
+		curpid = CURRENT_PID();
+	}
+
+	count = do_radix_tree(tt->pid_radix_tree, RADIX_TREE_COUNT, NULL);
+	if (CRASHDEBUG(1))
+		console("do_radix_tree: count: %ld\n", count);
+
+	retries = 0;
+	pidbuf = GETBUF(SIZE(pid));
+
+retry_radix_tree:
+	if (retries && DUMPFILE())
+		error(FATAL,
+			"\ncannot gather a stable task list via radix tree\n");
+
+	if ((retries == MAX_UNLIMITED_TASK_RETRIES) &&
+	    !(tt->flags & TASK_INIT_DONE))
+		error(FATAL,
+		    "\ncannot gather a stable task list via radix tree (%d retries)\n",
+			retries);
+
+	if (count > tt->max_tasks) {
+		tt->max_tasks = count + TASK_SLUSH;
+		allocate_task_space(tt->max_tasks);
+	}
+
+	BZERO(tt->task_local, tt->max_tasks * sizeof(void *));
+	tt->callbacks = 0;
+	rtp.index = 0;
+	rtp.value = (void *)&radix_tree_task_callback;
+	count = do_radix_tree(tt->pid_radix_tree, RADIX_TREE_DUMP_CB, &rtp);
+	if (CRASHDEBUG(1))
+		console("do_radix_tree: count: %ld  tt->callbacks: %d\n", count, tt->callbacks);
+
+	if (count > tt->max_tasks) {
+		retries++;
+		goto retry_radix_tree;
+	}
+
+	if (!hq_open()) {
+		error(INFO, "cannot hash task_struct entries\n");
+		if (!(tt->flags & TASK_INIT_DONE))
+			clean_exit(1);
+		error(INFO, "using stale task_structs\n");
+		return;
+       }
+
+	/*
+	 *  Get the idle threads first.
+	 */
+	cnt = 0;
+	for (i = 0; i < kt->cpus; i++) {
+		if (!tt->idle_threads[i])
+			continue;
+		if (hq_enter(tt->idle_threads[i]))
+			cnt++;
+		else
+			error(WARNING, "%sduplicate idle tasks?\n",
+				DUMPFILE() ? "\n" : "");
+	}
+
+	for (i = 0; i < tt->max_tasks; i++) {
+		tlp = (ulong *)tt->task_local;
+		tlp += i;
+		if ((next = *tlp) == 0)
+			break;
+
+		/*
+		 *  Translate radix tree contents to PIDTYPE_PID task.
+		 *  - the radix tree contents are struct pid pointers
+		 *  - upid is contained in pid.numbers[0]
+		 *  - upid.ns should point to init->init_pid_ns
+		 *  - pid->tasks[0] is first hlist_node in task->pids[3]
+		 *  - get task from address of task->pids[0]
+		 */
+		if (!readmem(next, KVADDR, pidbuf,
+		    SIZE(pid), "pid", RETURN_ON_ERROR|QUIET)) {
+			error(INFO, "\ncannot read pid struct from radix tree\n");
+			if (DUMPFILE())
+				continue;
+			hq_close();
+			retries++;
+			goto retry_radix_tree;
+		}
+
+		upid_ns = ULONG(pidbuf + OFFSET(pid_numbers) + OFFSET(upid_ns));
+		if (upid_ns != tt->init_pid_ns)
+			continue;
+		pid_tasks_0 = ULONG(pidbuf + OFFSET(pid_tasks));
+		if (!pid_tasks_0)
+			continue;
+		task = pid_tasks_0 - OFFSET(task_struct_pids);
+
+		if (CRASHDEBUG(1))
+			console("pid: %lx  ns: %lx  tasks[0]: %lx task: %lx\n",
+				next, upid_ns, pid_tasks_0, task);
+
+		if (is_idle_thread(task))
+			continue;
+
+		if (!IS_TASK_ADDR(task)) {
+			error(INFO, "%s: IDR radix tree: invalid task address: %lx\n",
+				DUMPFILE() ? "\n" : "", task);
+			if (DUMPFILE())
+				break;
+			hq_close();
+			retries++;
+			goto retry_radix_tree;
+		}
+
+		if (!hq_enter(task)) {
+			error(INFO, "%s: IDR radix tree: duplicate task: %lx\n",
+				DUMPFILE() ? "\n" : "", task);
+			if (DUMPFILE())
+				break;
+			hq_close();
+			retries++;
+			goto retry_radix_tree;
+		}
+
+		cnt++;
+	}
+
+	BZERO(tt->task_local, tt->max_tasks * sizeof(void *));
+	cnt = retrieve_list((ulong *)tt->task_local, cnt);
+	hq_close();
+
+	clear_task_cache();
+
+        for (i = 0, tlp = (ulong *)tt->task_local,
+             tt->running_tasks = 0, tc = tt->context_array;
+             i < tt->max_tasks; i++, tlp++) {
+		if (!(*tlp))
+			continue;
+
+		if (!IS_TASK_ADDR(*tlp)) {
+			error(WARNING,
+		            "%sinvalid task address found in task list: %lx\n",
+				DUMPFILE() ? "\n" : "", *tlp);
+			if (DUMPFILE())
+				continue;
+			retries++;
+			goto retry_radix_tree;
+		}
+
+		if (task_exists(*tlp)) {
+			error(WARNING,
+		           "%sduplicate task address found in task list: %lx\n",
+				DUMPFILE() ? "\n" : "", *tlp);
+			if (DUMPFILE())
+				continue;
+			retries++;
+			goto retry_radix_tree;
+		}
+
+		if (!(tp = fill_task_struct(*tlp))) {
+			if (DUMPFILE())
+				continue;
+			retries++;
+			goto retry_radix_tree;
+		}
+
+		if (store_context(tc, *tlp, tp)) {
+			tc++;
+			tt->running_tasks++;
+		}
+	}
+
+	FREEBUF(pidbuf);
+
+	please_wait_done();
+
+	if (ACTIVE() && (tt->flags & TASK_INIT_DONE))
+		refresh_context(curtask, curpid);
+
+	tt->retries = MAX(tt->retries, retries);
+}
+
 static void
 refresh_active_task_table(void)
 {
@@ -7054,6 +7326,8 @@ dump_task_table(int verbose)
                 fprintf(fp, "refresh_hlist_task_table_v3()\n");
         else if (tt->refresh_task_table == refresh_active_task_table)
                 fprintf(fp, "refresh_active_task_table()\n");
+        else if (tt->refresh_task_table == refresh_radix_tree_task_table)
+                fprintf(fp, "refresh_radix_tree_task_table()\n");
 	else
 		fprintf(fp, "%lx\n", (ulong)tt->refresh_task_table);
 
@@ -7090,6 +7364,9 @@ dump_task_table(int verbose)
         if (tt->flags & PID_HASH)
                 sprintf(&buf[strlen(buf)], 
 			"%sPID_HASH", others++ ? "|" : "");
+	if (tt->flags & PID_RADIX_TREE)
+		sprintf(&buf[strlen(buf)],
+			"%sPID_RADIX_TREE", others++ ? "|" : "");
         if (tt->flags & THREAD_INFO)
                 sprintf(&buf[strlen(buf)], 
 			"%sTHREAD_INFO", others++ ? "|" : "");
@@ -7122,6 +7399,8 @@ dump_task_table(int verbose)
 	fprintf(fp, "          task_end: %lx\n",  tt->task_end);
 	fprintf(fp, "        task_local: %lx\n",  (ulong)tt->task_local);
 	fprintf(fp, "         max_tasks: %d\n", tt->max_tasks);
+	fprintf(fp, "    pid_radix_tree: %lx\n", tt->pid_radix_tree);
+	fprintf(fp, "         callbacks: %d\n", tt->callbacks);
 	fprintf(fp, "        nr_threads: %d\n", tt->nr_threads);
 	fprintf(fp, "     running_tasks: %ld\n", tt->running_tasks);
 	fprintf(fp, "           retries: %ld\n", tt->retries);

commit a94b86e9eb3faa963a7c20517574d230837a4292
Author: Dave Anderson <anderson@redhat.com>
Date:   Tue Nov 28 12:12:50 2017 -0500

    Fix for the "net" command when the network device listing has an
    unusually large number of IP addresses.  In that case, without the
    patch, the command may generate a segmentation violation.
    (k-hagio@ab.jp.nec.com)

diff --git a/net.c b/net.c
index bb86963..4199091 100644
--- a/net.c
+++ b/net.c
@@ -70,7 +70,7 @@ static void show_net_devices_v3(ulong);
 static void print_neighbour_q(ulong, int);
 static void get_netdev_info(ulong, struct devinfo *);
 static void get_device_name(ulong, char *);
-static void get_device_address(ulong, char *);
+static long get_device_address(ulong, char **, long);
 static void get_sock_info(ulong, char *);
 static void dump_arp(void);
 static void arp_state_to_flags(unsigned char);
@@ -441,7 +441,8 @@ show_net_devices(ulong task)
 {
 	ulong next;
 	long flen;
-	char buf[BUFSIZE];
+	char *buf;
+	long buflen = BUFSIZE;
 
 	if (symbol_exists("dev_base_head")) {
 		show_net_devices_v2(task);
@@ -459,6 +460,7 @@ show_net_devices(ulong task)
 	if (!net->netdevice || !next)
 		return;
 
+	buf = GETBUF(buflen);
 	flen = MAX(VADDR_PRLEN, strlen(net->netdevice));
 
 	fprintf(fp, "%s  NAME   IP ADDRESS(ES)\n",
@@ -472,12 +474,14 @@ show_net_devices(ulong task)
 		get_device_name(next, buf);
 		fprintf(fp, "%-6s ", buf);
 
-		get_device_address(next, buf);
+		buflen = get_device_address(next, &buf, buflen);
 		fprintf(fp, "%s\n", buf);
 
         	readmem(next+net->dev_next, KVADDR, &next, 
 			sizeof(void *), "(net_)device.next", FAULT_ON_ERROR);
 	} while (next);
+
+	FREEBUF(buf);
 }
 
 static void
@@ -485,13 +489,15 @@ show_net_devices_v2(ulong task)
 {
 	struct list_data list_data, *ld;
 	char *net_device_buf;
-	char buf[BUFSIZE];
+	char *buf;
+	long buflen = BUFSIZE;
 	int ndevcnt, i;
 	long flen;
 
 	if (!net->netdevice) /* initialized in net_init() */
 		return;
 
+	buf = GETBUF(buflen);
 	flen = MAX(VADDR_PRLEN, strlen(net->netdevice));
 
 	fprintf(fp, "%s  NAME   IP ADDRESS(ES)\n",
@@ -521,12 +527,13 @@ show_net_devices_v2(ulong task)
 		get_device_name(ld->list_ptr[i], buf);
 		fprintf(fp, "%-6s ", buf);
 
-		get_device_address(ld->list_ptr[i], buf);
+		buflen = get_device_address(ld->list_ptr[i], &buf, buflen);
 		fprintf(fp, "%s\n", buf);
 	}
 	
 	FREEBUF(ld->list_ptr);
 	FREEBUF(net_device_buf);
+	FREEBUF(buf);
 }
 
 static void
@@ -535,13 +542,15 @@ show_net_devices_v3(ulong task)
 	ulong nsproxy_p, net_ns_p;
 	struct list_data list_data, *ld;
 	char *net_device_buf;
-	char buf[BUFSIZE];
+	char *buf;
+	long buflen = BUFSIZE;
 	int ndevcnt, i;
 	long flen;
 
 	if (!net->netdevice) /* initialized in net_init() */
 		return;
 
+	buf = GETBUF(buflen);
 	flen = MAX(VADDR_PRLEN, strlen(net->netdevice));
 
 	fprintf(fp, "%s  NAME   IP ADDRESS(ES)\n",
@@ -581,12 +590,13 @@ show_net_devices_v3(ulong task)
 		get_device_name(ld->list_ptr[i], buf);
 		fprintf(fp, "%-6s ", buf);
 
-		get_device_address(ld->list_ptr[i], buf);
+		buflen = get_device_address(ld->list_ptr[i], &buf, buflen);
 		fprintf(fp, "%s\n", buf);
 	}
 	
 	FREEBUF(ld->list_ptr);
 	FREEBUF(net_device_buf);
+	FREEBUF(buf);
 }
 
 /*
@@ -869,19 +879,24 @@ get_device_name(ulong devaddr, char *buf)
  *  in_ifaddr->ifa_next points to the next in_ifaddr in the list (if any).
  * 
  */
-static void
-get_device_address(ulong devaddr, char *buf)
+static long
+get_device_address(ulong devaddr, char **bufp, long buflen)
 {
 	ulong ip_ptr, ifa_list;
 	struct in_addr ifa_address;
+	char *buf;
+	char buf2[BUFSIZE];
+	long pos = 0;
 
-	BZERO(buf, BUFSIZE);
+	buf = *bufp;
+	BZERO(buf, buflen);
+	BZERO(buf2, BUFSIZE);
 
         readmem(devaddr + net->dev_ip_ptr, KVADDR,
         	&ip_ptr, sizeof(ulong), "ip_ptr", FAULT_ON_ERROR);
 
 	if (!ip_ptr)
-		return;
+		return buflen;
 
         readmem(ip_ptr + OFFSET(in_device_ifa_list), KVADDR,
         	&ifa_list, sizeof(ulong), "ifa_list", FAULT_ON_ERROR);
@@ -891,13 +906,20 @@ get_device_address(ulong devaddr, char *buf)
         		&ifa_address, sizeof(struct in_addr), "ifa_address", 
 			FAULT_ON_ERROR);
 
-		sprintf(&buf[strlen(buf)], "%s%s", 
-			strlen(buf) ? ", " : "",
-			inet_ntoa(ifa_address));
+		sprintf(buf2, "%s%s", pos ? ", " : "", inet_ntoa(ifa_address));
+		if (pos + strlen(buf2) >= buflen) {
+			RESIZEBUF(*bufp, buflen, buflen * 2);
+			buf = *bufp;
+			BZERO(buf + buflen, buflen);
+			buflen *= 2;
+		}
+		BCOPY(buf2, &buf[pos], strlen(buf2));
+		pos += strlen(buf2);
 
         	readmem(ifa_list + OFFSET(in_ifaddr_ifa_next), KVADDR,
         		&ifa_list, sizeof(ulong), "ifa_next", FAULT_ON_ERROR);
 	}
+	return buflen;
 }
 
 /*

commit 264f22dafe9f37780c4113fd08e8d5b2138edbce
Author: Dave Anderson <anderson@redhat.com>
Date:   Wed Nov 29 15:28:41 2017 -0500

    Fix for Linux 4.15 and later kernels that are configured with
    CONFIG_SPARSEMEM_EXTREME, and that contain kernel commit
    83e3c48729d9ebb7af5a31a504f3fd6aff0348c4, titled "mm/sparsemem:
    Allocate mem_section at runtime for CONFIG_SPARSEMEM_EXTREME=y".
    Without the patch, kernels configured with SPARSEMEM_EXTREME
    have changed the data type of "mem_section" from an array to
    a pointer, leading to errors in commands such as "kmem -p",
    "kmem -n", "kmem -s", and any other command that translates a
    physical address to its page struct address.
    (anderson@redhat.com)

diff --git a/memory.c b/memory.c
index 7537c43..0df8ecc 100644
--- a/memory.c
+++ b/memory.c
@@ -16928,7 +16928,7 @@ sparse_mem_init(void)
 {
 	ulong addr;
 	ulong mem_section_size;
-	int len, dimension;
+	int len, dimension, mem_section_is_ptr;
 
 	if (!IS_SPARSEMEM())
 		return;
@@ -16940,8 +16940,19 @@ sparse_mem_init(void)
 		error(FATAL, 
 		    "CONFIG_SPARSEMEM kernels not supported for this architecture\n");
 
+	/*
+	 *  The kernel's mem_section changed from array to pointer in this commit:
+	 *
+	 *   commit 83e3c48729d9ebb7af5a31a504f3fd6aff0348c4
+	 *   mm/sparsemem: Allocate mem_section at runtime for CONFIG_SPARSEMEM_EXTREME=y
+	 */
+	mem_section_is_ptr = 
+		get_symbol_type("mem_section", NULL, NULL) == TYPE_CODE_PTR ? 
+			TRUE : FALSE;
+
 	if (((len = get_array_length("mem_section", &dimension, 0)) ==
-	    (NR_MEM_SECTIONS() / _SECTIONS_PER_ROOT_EXTREME())) || !dimension)
+	    (NR_MEM_SECTIONS() / _SECTIONS_PER_ROOT_EXTREME())) || 
+	    mem_section_is_ptr || !dimension)
 		vt->flags |= SPARSEMEM_EX;
 
 	if (IS_SPARSEMEM_EX()) {
@@ -16960,7 +16971,7 @@ sparse_mem_init(void)
 		fprintf(fp, "SECTIONS_PER_ROOT = %ld\n", SECTIONS_PER_ROOT() );
 		fprintf(fp, "SECTION_ROOT_MASK = 0x%lx\n", SECTION_ROOT_MASK());
 		fprintf(fp, "PAGES_PER_SECTION = %ld\n", PAGES_PER_SECTION());
-		if (IS_SPARSEMEM_EX() && !len)
+		if (!mem_section_is_ptr && IS_SPARSEMEM_EX() && !len)
 			error(WARNING, "SPARSEMEM_EX: questionable section values\n");
 	}
 
@@ -16969,8 +16980,12 @@ sparse_mem_init(void)
 	if (!(vt->mem_section = (char *)malloc(SIZE(mem_section))))
 		error(FATAL, "cannot malloc mem_section cache\n");
 
-	addr = symbol_value("mem_section");
-	readmem(addr, KVADDR,vt->mem_sec ,mem_section_size,
+	if (mem_section_is_ptr)
+		get_symbol_data("mem_section", sizeof(void *), &addr);
+	else
+		addr = symbol_value("mem_section");
+
+	readmem(addr, KVADDR, vt->mem_sec, mem_section_size,
 		"memory section root table", FAULT_ON_ERROR);
 }
 

commit ed2abb47be9846be7a47d769c420ee3992cc0196
Author: Dave Anderson <anderson@redhat.com>
Date:   Wed Dec 13 11:18:05 2017 -0500

    With the latest PPC64 NMI IPI changes, crash_ipi_callback is found
    multiple times on the stack of active non-panic tasks.  Ensure that
    the symbol reference relates to an actual backtrace stack frame.
    (hbathini@linux.vnet.ibm.com)

diff --git a/ppc64.c b/ppc64.c
index 672ee60..0b04187 100644
--- a/ppc64.c
+++ b/ppc64.c
@@ -2337,6 +2337,14 @@ retry:
                         *nip = *up;
                         *ksp = bt->stackbase + 
 				((char *)(up) - 16 - bt->stackbuf);
+			/*
+			 * Check whether this symbol relates to a
+			 * backtrace or not
+			 */
+			ur_ksp =  *(ulong *)&bt->stackbuf[(*ksp) - bt->stackbase];
+			if (!INSTACK(ur_ksp, bt))
+				continue;
+
                         return TRUE;
                 }
 	}

commit b6c0fc74fa58d48a0b6801de790e86db1130d22f
Author: Dave Anderson <anderson@redhat.com>
Date:   Tue Jan 2 10:07:18 2018 -0500

    Update the starting virtual address of vmalloc space for kernels
    configured with CONFIG_X86_5LEVEL.
    (douly.fnst@cn.fujitsu.com)

diff --git a/defs.h b/defs.h
index ba9abad..4cd07b8 100644
--- a/defs.h
+++ b/defs.h
@@ -3316,7 +3316,7 @@ struct arm64_stackframe {
 
 #define USERSPACE_TOP_5LEVEL       0x0100000000000000
 #define PAGE_OFFSET_5LEVEL         0xff10000000000000
-#define VMALLOC_START_ADDR_5LEVEL  0xff92000000000000
+#define VMALLOC_START_ADDR_5LEVEL  0xffa0000000000000
 #define VMALLOC_END_5LEVEL         0xffd1ffffffffffff
 #define MODULES_VADDR_5LEVEL       0xffffffffa0000000
 #define MODULES_END_5LEVEL         0xffffffffff5fffff

commit cff3f2076ab52b9d6bae2b516fe3de32cccdb830
Author: Dave Anderson <anderson@redhat.com>
Date:   Tue Jan 2 10:29:54 2018 -0500

    Update the X86_64 VSYSCALL_END address to reflect that it only
    contains 1 page.
    (douly.fnst@cn.fujitsu.com)

diff --git a/defs.h b/defs.h
index 4cd07b8..97738a6 100644
--- a/defs.h
+++ b/defs.h
@@ -3324,7 +3324,7 @@ struct arm64_stackframe {
 #define VMEMMAP_END_5LEVEL         0xffd5ffffffffffff
 
 #define VSYSCALL_START             0xffffffffff600000
-#define VSYSCALL_END               0xffffffffffe00000
+#define VSYSCALL_END               0xffffffffff601000
 
 #define PTOV(X)               ((unsigned long)(X)+(machdep->kvbase))
 #define VTOP(X)               x86_64_VTOP((ulong)(X))

commit 3fe2663be5c6a5b160025a5a65b655a570e7e79e
Author: Dave Anderson <anderson@redhat.com>
Date:   Thu Jan 4 12:54:19 2018 -0500

    Prevent the X86_64 FILL_PML() macro from updating the internal
    machdep->machspec->last_pml4_read address every time a vmalloc'd
    kernel virtual address is translated.
    (douly.fnst@cn.fujitsu.com)

diff --git a/defs.h b/defs.h
index 97738a6..9a33b41 100644
--- a/defs.h
+++ b/defs.h
@@ -3344,7 +3344,7 @@ struct arm64_stackframe {
 #define PTRS_PER_P4D         512
 
 #define __PGDIR_SHIFT  (machdep->machspec->pgdir_shift)
- 
+
 #define pml4_index(address) (((address) >> PML4_SHIFT) & (PTRS_PER_PML4-1))
 #define p4d_index(address)  (((address) >> P4D_SHIFT) & (PTRS_PER_P4D - 1))
 #define pgd_index(address)  (((address) >> __PGDIR_SHIFT) & (PTRS_PER_PGD-1))
@@ -3353,26 +3353,24 @@ struct arm64_stackframe {
 
 #define IS_LAST_PML4_READ(pml4) ((ulong)(pml4) == machdep->machspec->last_pml4_read)
 
-#define FILL_PML4() { \
-	if (!(pc->flags & RUNTIME) || ACTIVE()) { \
-		if (!IS_LAST_PML4_READ(vt->kernel_pgd[0])) \
-                    readmem(vt->kernel_pgd[0], KVADDR, machdep->machspec->pml4, \
-                        PAGESIZE(), "init_level4_pgt", FAULT_ON_ERROR); \
-                machdep->machspec->last_pml4_read = (ulong)(vt->kernel_pgd[0]); \
-	} \
-}
+#define FILL_PML4() 									\
+	if (!(pc->flags & RUNTIME) || ACTIVE()) { 					\
+		if (!IS_LAST_PML4_READ(vt->kernel_pgd[0])) { 				\
+			readmem(vt->kernel_pgd[0], KVADDR, machdep->machspec->pml4, 	\
+					PAGESIZE(), "init_level4_pgt", FAULT_ON_ERROR); \
+			machdep->machspec->last_pml4_read = (ulong)(vt->kernel_pgd[0]); \
+		} 									\
+	}
 
-#define FILL_PML4_HYPER() { \
-	if (!machdep->machspec->last_pml4_read) { \
-		unsigned long idle_pg_table = \
-		    symbol_exists("idle_pg_table_4") ? symbol_value("idle_pg_table_4") : \
-			symbol_value("idle_pg_table"); \
-		readmem(idle_pg_table, KVADDR, \
-			machdep->machspec->pml4, PAGESIZE(), "idle_pg_table", \
-			FAULT_ON_ERROR); \
-		machdep->machspec->last_pml4_read = idle_pg_table; \
-	}\
-}
+#define FILL_PML4_HYPER() 								\
+	if (!machdep->machspec->last_pml4_read) { 					\
+		unsigned long idle_pg_table = symbol_exists("idle_pg_table_4") ? 	\
+						symbol_value("idle_pg_table_4") : 	\
+						symbol_value("idle_pg_table"); 	\
+		readmem(idle_pg_table, KVADDR, machdep->machspec->pml4, PAGESIZE(), 	\
+				"idle_pg_table", FAULT_ON_ERROR); 			\
+		machdep->machspec->last_pml4_read = idle_pg_table; 			\
+	}
 
 #define IS_LAST_UPML_READ(pml) ((ulong)(pml) == machdep->machspec->last_upml_read)
 

commit 63419fb9a535732082ae7b542ebb2399e6a3ccc9
Author: Dave Anderson <anderson@redhat.com>
Date:   Wed Jan 10 14:11:27 2018 -0500

    Fix for the "bt" command in x86_64 kernels that contain, or have
    backports of, kernel commit 4950d6d48a0c43cc61d0bbb76fb10e0214b79c66,
    titled "x86/dumpstack: Remove 64-byte gap at end of irq stack".
    Without the patch, backtraces fail to transition from the IRQ stack
    back to the process stack, showing an error message such as
    "bt: cannot transition exception stack to IRQ stack to current
    process stack".
    (anderson@redhat.com)

diff --git a/crash.8 b/crash.8
index 4b53f44..33af024 100644
--- a/crash.8
+++ b/crash.8
@@ -258,6 +258,7 @@ required in very rare circumstances:
 X86_64:
   phys_base=<physical-address>
   irq_eframe_link=<value>
+  irq_stack_gap=<value>
   max_physmem_bits=<value>
   kernel_image_size=<value>
   vm=orig       (pre-2.6.11 virtual memory address ranges)
diff --git a/defs.h b/defs.h
index 9a33b41..dcd6c26 100644
--- a/defs.h
+++ b/defs.h
@@ -1,8 +1,8 @@
 /* defs.h - core analysis suite
  *
  * Copyright (C) 1999, 2000, 2001, 2002 Mission Critical Linux, Inc.
- * Copyright (C) 2002-2017 David Anderson
- * Copyright (C) 2002-2017 Red Hat, Inc. All rights reserved.
+ * Copyright (C) 2002-2018 David Anderson
+ * Copyright (C) 2002-2018 Red Hat, Inc. All rights reserved.
  * Copyright (C) 2002 Silicon Graphics, Inc.
  *
  * This program is free software; you can redistribute it and/or modify
@@ -5768,6 +5768,7 @@ struct machine_specific {
         char *p4d;
 	ulong last_p4d_read;
 	struct ORC_data orc;
+	ulong irq_stack_gap;
 };
 
 #define KSYMS_START    (0x1)
diff --git a/help.c b/help.c
index e017b03..5b04b09 100644
--- a/help.c
+++ b/help.c
@@ -1,8 +1,8 @@
 /* help.c - core analysis suite
  *
  * Copyright (C) 1999, 2000, 2001, 2002 Mission Critical Linux, Inc.
- * Copyright (C) 2002-2017 David Anderson
- * Copyright (C) 2002-2017 Red Hat, Inc. All rights reserved.
+ * Copyright (C) 2002-2018 David Anderson
+ * Copyright (C) 2002-2018 Red Hat, Inc. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -159,6 +159,7 @@ char *program_usage_info[] = {
     "    X86_64:",
     "      phys_base=<physical-address>",
     "      irq_eframe_link=<value>",
+    "      irq_stack_gap=<value>",
     "      max_physmem_bits=<value>",
     "      kernel_image_size=<value>",
     "      vm=orig       (pre-2.6.11 virtual memory address ranges)",
diff --git a/x86_64.c b/x86_64.c
index 7d01140..d8fade4 100644
--- a/x86_64.c
+++ b/x86_64.c
@@ -1,7 +1,7 @@
 /* x86_64.c -- core analysis suite
  *
- * Copyright (C) 2004-2017 David Anderson
- * Copyright (C) 2004-2017 Red Hat, Inc. All rights reserved.
+ * Copyright (C) 2004-2018 David Anderson
+ * Copyright (C) 2004-2018 Red Hat, Inc. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -83,6 +83,7 @@ static void x86_64_init_kernel_pgd(void);
 static void x86_64_cpu_pda_init(void);
 static void x86_64_per_cpu_init(void);
 static void x86_64_ist_init(void);
+static void x86_64_irq_stack_gap_init(void);
 static void x86_64_post_init(void);
 static void parse_cmdline_args(void);
 static void x86_64_clear_machdep_cache(void);
@@ -181,6 +182,7 @@ x86_64_init(int when)
 		machdep->flags |= MACHDEP_BT_TEXT;
 		machdep->flags |= FRAMESIZE_DEBUG;
 		machdep->machspec->irq_eframe_link = UNINITIALIZED;
+		machdep->machspec->irq_stack_gap = UNINITIALIZED;
 		machdep->get_kvaddr_ranges = x86_64_get_kvaddr_ranges;
                 if (machdep->cmdline_args[0])
                         parse_cmdline_args();
@@ -638,6 +640,7 @@ x86_64_init(int when)
 				MEMBER_OFFSET("cpu_user_regs", "cs") - sizeof(ulong);
                 }
 		x86_64_irq_eframe_link_init();
+		x86_64_irq_stack_gap_init();
 		x86_64_framepointer_init();
 		x86_64_ORC_init();
 		x86_64_thread_return_init();
@@ -857,8 +860,6 @@ x86_64_dump_machdep_table(ulong arg)
 		fprintf(fp, "            last_p4d_read: (unused)\n");
 	}
 
-	fprintf(fp, "                 irqstack: %lx\n", (ulong)ms->irqstack);
-	fprintf(fp, "          irq_eframe_link: %ld\n", ms->irq_eframe_link);
 	fprintf(fp, "                 ORC_data: %s", machdep->flags & ORC ? "\n" : "(unused)\n");
 	if (machdep->flags & ORC) {
 		fprintf(fp, "                    module_ORC: %s\n", ms->orc.module_ORC ? "TRUE" : "FALSE");
@@ -931,6 +932,9 @@ x86_64_dump_machdep_table(ulong arg)
 	fprintf(fp, "            thread_return: %lx\n", ms->thread_return); 
 	fprintf(fp, "            page_protnone: %lx\n", ms->page_protnone); 
 
+	fprintf(fp, "                 irqstack: %lx\n", (ulong)ms->irqstack);
+	fprintf(fp, "          irq_eframe_link: %ld\n", ms->irq_eframe_link);
+	fprintf(fp, "            irq_stack_gap: %ld\n", ms->irq_stack_gap);
 	fprintf(fp, "                  stkinfo: isize: %d\n", 
 		ms->stkinfo.isize);
 	fprintf(fp, "                           esize[%d]: %d,%d,%d,%d,%d,%d,%d%s\n", 
@@ -1338,6 +1342,71 @@ x86_64_ist_init(void)
 	}
 }
 
+/*
+ *  Determine whether the unused gap at the top of the IRQ stack exists,
+ *  and store its size (either 0 or 64 bytes).
+ */
+static void 
+x86_64_irq_stack_gap_init(void)
+{
+	int c, cpus;
+	struct syment *sp;
+	ulong irq_stack_ptr;
+	struct machine_specific *ms = machdep->machspec;
+	
+	if (ms->irq_stack_gap != UNINITIALIZED)
+		return;
+
+	if (THIS_KERNEL_VERSION >= LINUX(4,9,0)) {
+		ms->irq_stack_gap = 0;
+		return;
+	}
+
+	ms->irq_stack_gap = 64;
+
+	/*
+	 *  Check for backports of this commit:
+	 *
+	 *    commit 4950d6d48a0c43cc61d0bbb76fb10e0214b79c66
+	 *    Author: Josh Poimboeuf <jpoimboe@redhat.com>
+	 *    Date:   Thu Aug 18 10:59:08 2016 -0500
+	 *
+	 *        x86/dumpstack: Remove 64-byte gap at end of irq stack
+	 */
+
+	if (!(sp = per_cpu_symbol_search("per_cpu__irq_stack_ptr")))
+		return;
+
+	/*
+	 *  CONFIG_SMP=n
+	 */
+	if (!(kt->flags & PER_CPU_OFF)) {
+		get_symbol_data(sp->name, sizeof(ulong), &irq_stack_ptr);
+		if ((irq_stack_ptr & 0xfff) == 0)
+			ms->irq_stack_gap = 0;
+		return;
+	}
+
+	/*
+	 *  Check the per-cpu irq_stack_ptr of the first possible cpu.
+	 */
+	if (!cpu_map_addr("possible"))
+		return;
+
+	cpus = kt->kernel_NR_CPUS ? kt->kernel_NR_CPUS : NR_CPUS;
+	for (c = 0; c < cpus; c++) {
+		if (!in_cpu_map(POSSIBLE, c))
+			continue;
+		if (readmem(sp->value + kt->__per_cpu_offset[c],
+		    KVADDR, &irq_stack_ptr, sizeof(void *), "irq_stack_ptr",
+		    QUIET|RETURN_ON_ERROR)) {
+			if ((irq_stack_ptr & 0xfff) == 0)
+				ms->irq_stack_gap = 0;
+			break;
+		}
+	}
+}
+
 static void 
 x86_64_post_init(void)
 { 
@@ -3352,7 +3421,7 @@ in_exception_stack:
                     	error(FATAL, "read of IRQ stack at %lx failed\n",
 				bt->stackbase);
 
-		stacktop = bt->stacktop - 64; /* from kernel code */
+		stacktop = bt->stacktop - ms->irq_stack_gap; 
 
 		bt->flags &= ~BT_FRAMESIZE_DISABLE;
 
@@ -3829,7 +3898,7 @@ in_exception_stack:
                     	error(FATAL, "read of IRQ stack at %lx failed\n",
 				bt->stackbase);
 
-		stacktop = bt->stacktop - 64; /* from kernel code */
+		stacktop = bt->stacktop - ms->irq_stack_gap;
 
 		if (!done) {
 			level = dwarf_backtrace(bt, level, stacktop);
@@ -5575,6 +5644,10 @@ x86_64_compiler_warning_stub(void)
  *
  *   --machdep irq_eframe_link=<offset>
  *
+ *  Force the IRQ stack gap size via:
+ *
+ *   --machdep irq_stack_gap=<size>
+ *
  *  Force max_physmem_bits via:
  *
  *   --machdep max_physmem_bits=<count>
@@ -5704,6 +5777,15 @@ parse_cmdline_args(void)
 						continue;
 					}
 				}
+	                } else if (STRNEQ(arglist[i], "irq_stack_gap=")) {
+	                        p = arglist[i] + strlen("irq_stack_gap=");
+				if (strlen(p)) {
+					value = stol(p, RETURN_ON_ERROR|QUIET, &errflag);
+					if (!errflag) {
+						machdep->machspec->irq_stack_gap = value;
+						continue;
+					}
+				}
 			} else if (STRNEQ(arglist[i], "max_physmem_bits=")) {
 	                        p = arglist[i] + strlen("max_physmem_bits=");
 				if (strlen(p)) {
