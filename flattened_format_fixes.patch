commit d304aab38b804207c21f0f77c25e737a6b81d490
Author: Dave Anderson <anderson@redhat.com>
Date:   Wed Apr 29 10:27:03 2015 -0400

    Speed up the session invocation time of "flattened" format dumpfiles
    created by the makedumpfile(8) facility.  When sorting the blocks of
    memory by their intended ELF or compressed kdump file offsets, the
    patch replaces the bubble-sort method that is currently used with an
    insertion sort method.
    (dslutz@verizon.com)

diff --git a/makedumpfile.c b/makedumpfile.c
index f6834b9..7872805 100644
--- a/makedumpfile.c
+++ b/makedumpfile.c
@@ -56,8 +56,10 @@ store_flat_data_array(char *file, struct flat_data **fda)
 {
 	int			result = FALSE, fd;
 	int64_t			offset_fdh;
+	int64_t			offset_report = 0;
 	unsigned long long	num_allocated = 0;
 	unsigned long long	num_stored    = 0;
+	unsigned long long	sort_idx;
 	unsigned long long	size_allocated;
 	struct flat_data	*ptr = NULL, *cur, *new;
 	struct makedumpfile_data_header	fdh;
@@ -100,11 +102,34 @@ store_flat_data_array(char *file, struct flat_data **fda)
 			break;
 		}
 		cur = ptr + num_stored;
+		sort_idx = num_stored;
+		while (sort_idx) {
+			new = ptr + --sort_idx;
+			if (new->off_rearranged >= fdh.offset) {
+				cur->off_flattened = new->off_flattened;
+				cur->off_rearranged = new->off_rearranged;
+				cur->buf_size = new->buf_size;
+				cur = new;
+			} else {
+				if (CRASHDEBUG(1) && sort_idx + 1 != num_stored) {
+					fprintf(fp,
+						"makedumpfile: Moved from %lld to %lld\n",
+						num_stored, sort_idx + 1);
+				}
+				break;
+			}
+		}
 		cur->off_flattened  = offset_fdh + sizeof(fdh);
 		cur->off_rearranged = fdh.offset;
 		cur->buf_size       = fdh.buf_size;
 		num_stored++;
 
+		if (CRASHDEBUG(1) && (fdh.offset >> 30) > (offset_report >> 30)) {
+			fprintf(fp, "makedumpfile: At %lld GiB\n",
+			      (ulonglong)(fdh.offset >> 30));
+			offset_report = fdh.offset;
+		}
+
 		/* seek for next makedumpfile_data_header. */
 		if (lseek(fd, fdh.buf_size, SEEK_CUR) < 0) {
 			error(INFO, "%s: seek error (flat format)\n", file);
@@ -121,35 +146,6 @@ store_flat_data_array(char *file, struct flat_data **fda)
 	return num_stored;
 }
 
-static void
-sort_flat_data_array(struct flat_data **fda, unsigned long long num_fda)
-{
-	unsigned long long	i, j;
-	struct flat_data	tmp, *cur_i, *cur_j;
-
-	for (i = 0; i < num_fda - 1; i++) {
-		for (j = i + 1; j < num_fda; j++) {
-			cur_i = *fda + i;
-			cur_j = *fda + j;
-
-			if (cur_i->off_rearranged < cur_j->off_rearranged)
-				continue;
-
-			tmp.off_flattened  = cur_i->off_flattened;
-			tmp.off_rearranged = cur_i->off_rearranged;
-			tmp.buf_size       = cur_i->buf_size;
-
-			cur_i->off_flattened  = cur_j->off_flattened;
-			cur_i->off_rearranged = cur_j->off_rearranged;
-			cur_i->buf_size       = cur_j->buf_size;
-
-			cur_j->off_flattened  = tmp.off_flattened;
-			cur_j->off_rearranged = tmp.off_rearranged;
-			cur_j->buf_size       = tmp.buf_size;
-		}
-	}
-}
-
 static int
 read_all_makedumpfile_data_header(char *file)
 {
@@ -161,8 +157,6 @@ read_all_makedumpfile_data_header(char *file)
 	if (retval < 0)
 		return FALSE;
 
-	sort_flat_data_array(&fda, num);
-
 	afd.num_array = num;
 	afd.array     = fda;
 

commit f95ecdc330a11d3701de859aab59a5ab5954aae6
Author: Dave Anderson <anderson@redhat.com>
Date:   Tue Jun 16 16:40:19 2015 -0400

    Speed up the "crash --osrelease" option when used with "flattened"
    format dumpfiles.  Without the patch, the rearranged data array
    initialization is performed before the vmcoreinfo data in the
    header is read, which can take a significant amount of time with
    large dumpfiles.  The patch simply looks for the appropriate
    vmcoreinfo data string near the beginning of the dumpfile.
    (anderson@redhat.com)

diff --git a/main.c b/main.c
index fd7f7a8..135e48b 100644
--- a/main.c
+++ b/main.c
@@ -1857,10 +1857,10 @@ get_osrelease(char *dumpfile)
 {
 	int retval = 1;
 
-	if (is_flattened_format(dumpfile))
-		pc->flags2 |= FLAT;
-	
-	if (is_diskdump(dumpfile)) {
+	if (is_flattened_format(dumpfile)) {
+		if (pc->flags2 & GET_OSRELEASE)
+			retval = 0;
+	} else if (is_diskdump(dumpfile)) {
 		if (pc->flags2 & GET_OSRELEASE)
 			retval = 0;
 	} else if (is_kdump(dumpfile, KDUMP_LOCAL)) {
diff --git a/makedumpfile.c b/makedumpfile.c
index 7872805..c24cbd4 100644
--- a/makedumpfile.c
+++ b/makedumpfile.c
@@ -22,6 +22,8 @@
 #include "makedumpfile.h"
 #include <byteswap.h>
 
+static void flattened_format_get_osrelease(char *);
+
 int flattened_format = 0;
 
 struct flat_data {
@@ -166,10 +168,16 @@ read_all_makedumpfile_data_header(char *file)
 void
 check_flattened_format(char *file)
 {
-	int fd;
+	int fd, get_osrelease;
 	struct stat stat;
 	struct makedumpfile_header fh;
 
+	if (pc->flags2 & GET_OSRELEASE) {
+		get_osrelease = TRUE;
+		pc->flags2 &= ~GET_OSRELEASE;
+	} else
+		get_osrelease = FALSE;
+
 	if (flattened_format)
 		return;
 
@@ -196,6 +204,11 @@ check_flattened_format(char *file)
 	    (fh.type != TYPE_FLAT_HEADER))
 		return;
 
+	if (get_osrelease) {
+		flattened_format_get_osrelease(file);
+		return;
+	}
+
 	if (!read_all_makedumpfile_data_header(file))
 		return;
 
@@ -320,3 +333,28 @@ dump_flat_header(FILE *ofp)
 	fprintf(ofp, "              array: %lx\n", (ulong)afd.array);
 	fprintf(ofp, "          file_size: %ld\n\n", (ulong)afd.file_size);
 }
+
+static void 
+flattened_format_get_osrelease(char *file)
+{
+	int c;
+	FILE *pipe;
+	char buf[BUFSIZE], *p1, *p2;
+
+	c = strlen("OSRELEASE=");
+	sprintf(buf, "/usr/bin/strings -n %d %s", c, file);
+			
+	if ((pipe = popen(buf, "r")) == NULL)
+		return;
+
+        for (c = 0; (c < 100) && fgets(buf, BUFSIZE-1, pipe); c++) {
+		if ((p1 = strstr(buf, "OSRELEASE="))) {
+			p2 = strstr(p1, "=");
+			fprintf(fp, "%s", p2+1);
+			flattened_format = TRUE;
+			pc->flags2 |= GET_OSRELEASE;
+		}
+	}
+
+	fclose(fp);
+}

commit fbf9a6fed13d37caf7f44f94a96cff1d5d50087a
Author: Dave Anderson <anderson@redhat.com>
Date:   Thu Jun 18 15:33:50 2015 -0400

    Fix for the initialization-time sorting mechanism required for
    "flattened format" dumpfiles if the dumpfile is truncated/incomplete.
    Without the patch, the sorting function continues performing invalid
    reads beyond the of the dumpfile, which may lead to an infinite loop
    instead of a session-ending error message.  In addition, since the
    sorting operation may take several minutes, a "please wait" message
    with an incrementing percentage-complete counter will be displayed.
    (anderson@redhat.com)

diff --git a/makedumpfile.c b/makedumpfile.c
index c24cbd4..b8e8f0f 100644
--- a/makedumpfile.c
+++ b/makedumpfile.c
@@ -18,6 +18,7 @@
  * Author: Ken'ichi Ohmichi <oomichi mxs nes nec co jp>
  */
 
+#define _LARGEFILE64_SOURCE 1  /* stat64() */
 #include "defs.h"
 #include "makedumpfile.h"
 #include <byteswap.h>
@@ -65,6 +66,10 @@ store_flat_data_array(char *file, struct flat_data **fda)
 	unsigned long long	size_allocated;
 	struct flat_data	*ptr = NULL, *cur, *new;
 	struct makedumpfile_data_header	fdh;
+	struct stat64		stat;
+	ulonglong		pct, last_pct;
+	char			buf[BUFSIZE];
+	ssize_t			bytes_read;
 
 	fd = open(file, O_RDONLY);
 	if (fd < 0) {
@@ -76,6 +81,13 @@ store_flat_data_array(char *file, struct flat_data **fda)
 		close(fd);
 		return -1;
 	}
+	if (stat64(file, &stat) < 0) {
+		error(INFO, "cannot stat64 %s\n", file);
+                return -1;
+	}
+
+	please_wait("sorting flat format data");
+	pct = last_pct = 0;
 	while (1) {
 		if (num_allocated <= num_stored) {
 			num_allocated += 100;
@@ -91,8 +103,13 @@ store_flat_data_array(char *file, struct flat_data **fda)
 		}
 		offset_fdh = lseek(fd, 0x0, SEEK_CUR);
 
-		if (read(fd, &fdh, sizeof(fdh)) < 0) {
-			error(INFO, "read error: %s (flat format)\n", file);
+		if ((bytes_read = read(fd, &fdh, sizeof(fdh))) != sizeof(fdh)) {
+			if (bytes_read >= 0)
+				error(INFO, 
+				    "read error: %s (flat format): truncated/incomplete\n", 
+					file);
+			else
+				error(INFO, "read error: %s (flat format)\n", file);
 			break;
 		}
 		if (!is_bigendian()){
@@ -126,6 +143,15 @@ store_flat_data_array(char *file, struct flat_data **fda)
 		cur->buf_size       = fdh.buf_size;
 		num_stored++;
 
+		pct = (offset_fdh * 100ULL) / stat.st_size; 
+		if (pct > last_pct) {
+			sprintf(buf, "sorting flat format data: %lld%%", (ulonglong)pct);
+			please_wait(buf);
+			if (CRASHDEBUG(1))
+				fprintf(fp, "\n");
+			last_pct = pct;
+		}
+
 		if (CRASHDEBUG(1) && (fdh.offset >> 30) > (offset_report >> 30)) {
 			fprintf(fp, "makedumpfile: At %lld GiB\n",
 			      (ulonglong)(fdh.offset >> 30));
@@ -138,6 +164,8 @@ store_flat_data_array(char *file, struct flat_data **fda)
 			break;
 		}
 	}
+	please_wait_done();
+
 	close(fd);
 	if (result == FALSE) {
 		free(ptr);

commit 7a2ff137feed088c6e1378f8b1314760ef1324b6
Author: Dave Anderson <anderson@redhat.com>
Date:   Wed Jul 1 16:25:56 2015 -0400

    Commit f95ecdc330a11d3701de859aab59a5ab5954aae6 above to speed up
    "crash --osrelease" for flattened format dumpfiles inadvertently
    broke the option for ELF kdump and compressed kdump dumpfiles.
    (anderson@redhat.com)

diff --git a/makedumpfile.c b/makedumpfile.c
index b8e8f0f..1fc216c 100644
--- a/makedumpfile.c
+++ b/makedumpfile.c
@@ -207,20 +207,20 @@ check_flattened_format(char *file)
 		get_osrelease = FALSE;
 
 	if (flattened_format)
-		return;
+		goto out;
 
 	if (file_exists(file, &stat) && S_ISCHR(stat.st_mode))
-		return;
+		goto out;
 
 	fd = open(file, O_RDONLY);
 	if (fd < 0) {
 		error(INFO, "unable to open dump file %s\n", file);
-		return;
+		goto out;
 	}
 	if (read(fd, &fh, sizeof(fh)) < 0) {
 		error(INFO, "unable to read dump file %s\n", file);
 		close(fd);
-		return;
+		goto out;
 	}
 	close(fd);
 
@@ -230,7 +230,7 @@ check_flattened_format(char *file)
 	}
 	if ((strncmp(fh.signature, MAKEDUMPFILE_SIGNATURE, sizeof(MAKEDUMPFILE_SIGNATURE)) != 0) || 
 	    (fh.type != TYPE_FLAT_HEADER))
-		return;
+		goto out;
 
 	if (get_osrelease) {
 		flattened_format_get_osrelease(file);
@@ -246,6 +246,11 @@ check_flattened_format(char *file)
 	fh_save = fh;
 
 	flattened_format = TRUE;
+	return;
+
+out:
+	if (get_osrelease)
+		pc->flags2 |= GET_OSRELEASE;
 }
 
 static int

commit 8eb8fcc719e0fae1752619fccd1c8c3f906af3e8
Author: Dave Anderson <anderson@redhat.com>
Date:   Tue Jul 14 14:56:11 2015 -0400

    Fix for the "crash --osrelease" option for flattened format dumpfiles
    in the unlikely event that the dumpfile header does not contain the
    VMCOREINFO note section from the original ELF /proc/vmcore.  Without
    the patch, the command displays nothing instead of showing "unknown".
    (anderson@redhat.com)

diff --git a/makedumpfile.c b/makedumpfile.c
index 1fc216c..ebf24f5 100644
--- a/makedumpfile.c
+++ b/makedumpfile.c
@@ -389,5 +389,5 @@ flattened_format_get_osrelease(char *file)
 		}
 	}
 
-	fclose(fp);
+	fclose(pipe);
 }

