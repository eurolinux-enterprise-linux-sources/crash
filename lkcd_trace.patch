--- crash-7.1.0/lkcd_x86_trace.c.orig
+++ crash-7.1.0/lkcd_x86_trace.c
@@ -5,8 +5,8 @@
 /* 
  *  lkcd_x86_trace.c
  *
- *  Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012 David Anderson
- *  Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012 Red Hat, Inc. All rights reserved.
+ *  Copyright (C) 2002-2012, 2017 David Anderson
+ *  Copyright (C) 2002-2012, 2017 Red Hat, Inc. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
@@ -44,6 +44,7 @@ static syment_t *kl_lkup_symaddr(kaddr_t
 static k_error_t kl_get_task_struct(kaddr_t, int, void *);
 static kaddr_t kl_kernelstack(kaddr_t);
 static kaddr_t get_call_pc(kaddr_t);
+static kaddr_t get_call_pc_v2(kaddr_t);
 static int get_jmp_instr(kaddr_t, kaddr_t, kaddr_t *, char *, char **);
 static int is_push(unsigned int);
 static int is_pop(unsigned int);
@@ -278,9 +279,75 @@ get_call_pc(kaddr_t ra)
 		addr = irp->prev->addr;
 	}
 	free_instr_stream(irp);
+
+	/*
+	 *  If the old LKCD code fails, try disassembling...
+	 */
+	if (!addr)
+		return get_call_pc_v2(ra);
+
 	return(addr);
 }
 
+kaddr_t
+get_call_pc_v2(kaddr_t ra)
+{
+	int c ATTRIBUTE_UNUSED; 
+	int line, len;
+	kaddr_t addr, addr2;
+	ulong offset;
+	struct syment *sp;
+	char *arglist[MAXARGS];
+	char buf[BUFSIZE];
+
+	if ((sp = value_search(ra, &offset))) {
+		if (offset == 0)
+			return 0;
+	} else
+		return 0;
+
+	addr = 0;
+
+	for (len = 2; len < 8; len++) {
+        	open_tmpfile2();
+	        sprintf(buf, "x/2i 0x%x", ra - len);
+	        if (!gdb_pass_through(buf, pc->tmpfile2, GNU_RETURN_ON_ERROR)) {
+	                close_tmpfile2();
+	                return 0;
+	        }
+	
+	        rewind(pc->tmpfile2);
+		line = 1;
+	        while (fgets(buf, BUFSIZE, pc->tmpfile2)) {
+	                c = parse_line(buf, arglist);
+			if ((line == 1) && !STREQ(arglist[2], "call"))
+				break;
+			if (line == 2) {
+				addr2 = (kaddr_t)htol(arglist[0], RETURN_ON_ERROR|QUIET, 0);
+				if (addr2 == ra) {
+					addr = ra - len;
+					break;
+				}
+			}
+			line++;
+		}
+
+		close_tmpfile2();
+
+		if (addr) {
+			if (CRASHDEBUG(1)) {
+				fprintf(fp, "get_call_pc_v2(ra: %x) -> %x -> ", ra, addr); 
+				if (value_to_symstr(addr, buf, 0))
+					fprintf(fp, "%s", buf);
+				fprintf(fp, "\n");
+			}
+			break;
+		}
+	}
+
+	return addr;
+}
+
 /*
  * get_jmp_instr()
  */
@@ -581,7 +648,7 @@ framesize_modify(struct framesize_cache 
 		fc->bp_adjust = fmp->post_adjust;
 
 	if (fmp->called_function) {
-        	if (STREQ(fmp->called_function,x86_function_called_by(fc->pc)));
+		if (STREQ(fmp->called_function,x86_function_called_by(fc->pc)))
 			fc->flags |= FRAMESIZE_VALIDATE;
 	}
 
@@ -1341,7 +1408,7 @@ eframe_incr(kaddr_t addr, char *funcname
 	console("  next: %lx size: %d  opcode: 0x%x insn: \"%s\"\n",
 		next, size, irp.opcode, irp.opcodep->name);
 
-	if (STREQ(irp.opcodep->name, "jmp"))
+	if (STREQ(irp.opcodep->name, "jmp") || STREQ(irp.opcodep->name, "nop"))
 		val = 4;
 	else
 		val = 12;
@@ -1718,7 +1785,9 @@ find_trace(
 					ra, sp, bp, asp, 0, 0, 0, EX_FRAME|SET_EX_FRAME_ADDR);
 				return(trace->nframes);
 #ifdef REDHAT
-                        } else if (STREQ(func_name, "cpu_idle")) {
+                        } else if (STREQ(func_name, "cpu_idle") ||
+				STREQ(func_name, "cpu_startup_entry") ||
+				STREQ(func_name, "start_secondary")) {
                                 ra = 0;
                                 bp = sp = saddr - 4;
                                 asp = curframe->asp;
@@ -2137,6 +2206,7 @@ task_trace(kaddr_t task, int flags, FILE
 {
 	void *tsp;
 	kaddr_t saddr, eip, esp;
+	ulong contents;
 	trace_t *trace;
 
 #ifdef REDHAT
@@ -2259,6 +2329,14 @@ task_trace(kaddr_t task, int flags, FILE
 		}
 	}
 
+	if (STREQ(kl_funcname(bt->instptr), "crash_kexec") ||
+	    STREQ(kl_funcname(bt->instptr), "crash_nmi_callback")) {
+		if (readmem(bt->stkptr-4, KVADDR, &contents, sizeof(ulong), 
+		    "stkptr-4 contents", RETURN_ON_ERROR|QUIET) &&
+		    (contents == bt->instptr))
+			bt->stkptr -= 4;
+	}
+
 	if (!verify_back_trace(bt) && !recoverable(bt, ofp) && 
 	    !BT_REFERENCE_CHECK(bt))
 		error(INFO, "cannot resolve stack trace:\n");
@@ -2732,16 +2810,20 @@ eframe_label(char *funcname, ulong eip)
 	efp = &eframe_labels;
 
 	if (!efp->init) {
-		if (!(efp->syscall = symbol_search("system_call")))
-			error(WARNING, 
-			   "\"system_call\" symbol does not exist\n");
+		if (!(efp->syscall = symbol_search("system_call"))) {
+			if (CRASHDEBUG(1))
+				error(WARNING, 
+					"\"system_call\" symbol does not exist\n");
+		}
 		if ((sp = symbol_search("ret_from_sys_call")))
 			efp->syscall_end = sp;
 		else if ((sp = symbol_search("syscall_badsys")))
 			efp->syscall_end = sp;
-		else
-			error(WARNING, 
+		else {
+			if (CRASHDEBUG(1)) 
+				error(WARNING, 
         "neither \"ret_from_sys_call\" nor \"syscall_badsys\" symbols exist\n");
+		}
 
 		if (efp->syscall) {
                 	efp->tracesys = symbol_search("tracesys");
